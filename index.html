<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChitChatTalk</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .header-container {
            width: 100%;
            padding: 20px 0;
            text-align: center;
            background: linear-gradient(135deg, #007bff, #00c6ff);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .header-container h1 {
            color: #fff;
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            overflow: hidden;
            position: relative;
        }

        .header-container h1 span {
            display: inline-block;
            animation: slide-in 2s ease-in-out forwards, fade-in 3s ease-in-out forwards;
            opacity: 0;
        }

        .header-container p {
            color: #fff;
            font-size: 1.2rem;
            opacity: 0.8;
            font-weight: 300;
        }

        @keyframes slide-in {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        #video-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
            margin-top: 20px;
        }

        video {
            width: 100%;
            max-width: 500px;
            height: auto;
            border: 2px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            background-color: #007bff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #0056b3;
        }

        #chat-box {
            width: 100%;
            max-width: 800px;
            height: 200px;
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            margin-top: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        #chat-box p {
            margin-bottom: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        input {
            padding: 10px;
            width: calc(100% - 20px);
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .header-container h1 {
                font-size: 2rem;
            }

            button {
                font-size: 0.9rem;
                padding: 8px 16px;
            }

            #chat-box {
                height: 150px;
            }

            .button-container {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="header-container">
        <h1><span>ChitChatTalk</span> Video Chat</h1>
        <p>Seamless video and audio communication</p>
    </div>

    <div id="video-container">
        <video id="localVideo" autoplay playsinline muted></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <div class="button-container">
        <button id="startCall">Start Call</button>
        <button id="refreshCall">Reconnect</button>
        <button id="skipUser">Skip User</button>
        <button id="muteButton">Mute</button>
    </div>

    <div id="chat-box"></div>
    <input type="text" id="chatInput" placeholder="Type a message..." />
    <button id="sendMessage">Send</button>

    <script>
        let signalingSocket;
        let localStream;
        let peerConnection;
        let isReconnecting = false;
        let isMuted = false;

        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");
        const startCallButton = document.getElementById("startCall");
        const refreshCallButton = document.getElementById("refreshCall");
        const skipUserButton = document.getElementById("skipUser");
        const chatInput = document.getElementById("chatInput");
        const sendMessageButton = document.getElementById("sendMessage");
        const muteButton = document.getElementById("muteButton");

        const iceServers = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }] // Public STUN server
        };

        function logMessage(message) {
            const chatBox = document.getElementById("chat-box");
            const newMessage = document.createElement("p");
            newMessage.textContent = message;
            chatBox.appendChild(newMessage);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function connectWebSocket() {
            signalingSocket = new WebSocket("wss://api.chitchattalk.in/chat");

            signalingSocket.onopen = () => {
                logMessage("Connected to signaling server.");
                if (isReconnecting) {
                    startWebRTC();  // Restart WebRTC connection on reconnection
                }
            };

            signalingSocket.onmessage = (message) => {
                const data = JSON.parse(message.data);

                if (data.type === "offer") {
                    handleOffer(data.offer);
                } else if (data.type === "answer") {
                    handleAnswer(data.answer);
                } else if (data.type === "ice-candidate") {
                    handleNewICECandidate(data.candidate);
                } else if (data.type === "chat") {
                    logMessage("Remote: " + data.message);
                }
            };

            signalingSocket.onerror = (error) => {
                logMessage("WebSocket Error: " + error);
            };

            signalingSocket.onclose = () => {
                logMessage("WebSocket connection closed. Attempting to reconnect...");
                isReconnecting = true;
                setTimeout(() => {
                    connectWebSocket(); // Reconnect WebSocket after a short delay
                }, 2000);
            };
        }

        startCallButton.onclick = async () => {
            await startWebRTC();
        };

        refreshCallButton.onclick = async () => {
            logMessage("Reconnecting to a new user...");
            resetConnections(); 
            startWebRTC();
        };

        skipUserButton.onclick = async () => {
            logMessage("Skipping current user...");
            resetConnections(); 
            startWebRTC();
        };

        sendMessageButton.onclick = () => {
            const message = chatInput.value;
            if (message.trim() !== "") {
                logMessage("You: " + message);
                signalingSocket.send(JSON.stringify({ type: "chat", message: message }));
                chatInput.value = ""; 
            }
        };

        async function startWebRTC() {
            if (!localStream) {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
            }

            peerConnection = new RTCPeerConnection(iceServers);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        type: "ice-candidate",
                        candidate: event.candidate
                    }));
                }
            };

            peerConnection.ontrack = event => {
                remoteVideo.srcObject = event.streams[0];
            };

            peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    logMessage("Peer connection lost. Trying to reconnect...");
                    resetConnections();
                    startWebRTC();
                }
            };

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            signalingSocket.send(JSON.stringify({
                type: "offer",
                offer: peerConnection.localDescription
            }));
        }

        function resetConnections() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            remoteVideo.srcObject = null;
        }

        function handleOffer(offer) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
                .then(() => {
                    return peerConnection.createAnswer();
                })
                .then(answer => {
                    return peerConnection.setLocalDescription(answer);
                })
                .then(() => {
                    signalingSocket.send(JSON.stringify({
                        type: "answer",
                        answer: peerConnection.localDescription
                    }));
                    logMessage("Answer sent to the server.");
                })
                .catch(error => {
                    logMessage("Error handling offer: " + error);
                });
        }

        function handleAnswer(answer) {
            peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
                .then(() => {
                    logMessage("Answer received from remote peer.");
                })
                .catch(error => {
                    logMessage("Error setting remote description: " + error);
                });
        }

        function handleNewICECandidate(candidate) {
            peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                .then(() => {
                    logMessage("New ICE candidate added.");
                })
                .catch(error => {
                    logMessage("Error adding ICE candidate: " + error);
                });
        }

        connectWebSocket();
    </script>
</body>
</html>
